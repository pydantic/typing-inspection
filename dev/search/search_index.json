{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"typing-inspection","text":"<p><code>typing-inspection</code> provides tools to inspect type annotations at runtime.</p>"},{"location":"#installation","title":"Installation","text":"<p>From PyPI:</p> <pre><code>pip install typing-inspection\n</code></pre> <p>The library can be imported from the <code>typing_inspection</code> module.</p>"},{"location":"usage/","title":"Usage","text":"<p>The library is divided into two submodules:</p> <ul> <li> <p><code>typing_inspection.typing_objects</code>: provides functions to check if a variable is a <code>typing</code> object:   <pre><code>from typing_extensions import Union, get_origin\n\nfrom typing_inspection.typing_objects import is_union\n\nis_union(get_origin(Union[int, str]))  # True\n</code></pre></p> <p>Note</p> <p>You might be tempted to use a simple identity check:</p> <pre><code>&gt;&gt;&gt; get_origin(Union[int, str]) is typing.Union\n</code></pre> <p>However, <code>typing_extensions</code> might provide a different version of the <code>typing</code> objects. Instead, the <code>typing_objects</code> functions make sure to check against both variants, if they are different.</p> </li> <li> <p><code>typing_inspection.introspection</code>: provides high-level introspection functions, taking runtime edge cases   into account.</p> </li> </ul>"},{"location":"usage/#inspecting-annotations","title":"Inspecting annotations","text":"<p>If, as a library, you rely heavily on type hints, you may encounter subtle unexpected behaviors and performance issues when inspecting annotations. As such, this section provides a recommended workflow to do so.</p>"},{"location":"usage/#fetching-type-hints","title":"Fetching type hints","text":"<p>The first step is to gather the type annotations from the object you want to inspect. The <code>typing.get_type_hints()</code> function can be used to do so. If you want to make use of annotated metadata, make sure to set the <code>include_extras</code> argument to <code>True</code>.</p> <pre><code>&gt;&gt;&gt; class A:\n...    x: int\n...    y: Annotated[int, ...]\n...\n&gt;&gt;&gt; get_type_hints(A, include_extras=True)\n{'x': int, 'y': Annotated[int, ...]}\n</code></pre> <p>Note</p> <p>Currently, <code>typing-inspection</code> does not provide any utility to fetch (and evaluate) type annotations. The current <code>typing</code> utilities might contain subtle bugs across the different Python versions, so there is value in having similar functionality. It might be best to wait for PEP 649 to be fully implemented first. In the meanwhile, the <code>typing_extensions.get_type_hints()</code> backport can be used.</p>"},{"location":"usage/#unpacking-metadata-and-qualifiers","title":"Unpacking metadata and qualifiers","text":"<p>The annotations fetched in the previous step are called annotation expressions. An annotation expression is a type expression, optionally surrounded by one or more type qualifiers or by the <code>Annotated</code> form.</p> <p>For instance, in the following example:</p> <pre><code>from typing import Annotated, ClassVar\n\nclass A:\n    x: ClassVar[Annotated[int, \"meta\"]]\n</code></pre> <p>The type hint of <code>x</code> is an annotation expression. The underlying type expression is <code>int</code>. It is wrapped by the <code>ClassVar</code> type qualifier, and the <code>Annotated</code> special form.</p> <p>The goal of this step is to:</p> <ul> <li>Unwrap the underlying type expression.</li> <li>Keep track of the type qualifiers and annotated metadata.</li> </ul> <p>To unwrap the type hint, use the <code>inspect_annotation()</code> function:</p> <pre><code>&gt;&gt;&gt; from typing_inspection.introspection import AnnotationSource, inspect_annotation\n&gt;&gt;&gt; inspect_annotation(\n...    ClassVar[Annotated[int, \"meta\"]],\n...    annotation_source=AnnotationSource.CLASS,\n... )\n...\nInspectedAnnotation(type=int, qualifiers={\"class_var\"}, metadata=[\"meta\"])\n</code></pre> <p>Note that depending on the annotation source, different type qualifiers can be (dis)allowed. For instance, <code>TypedDict</code> classes allow <code>Required</code> and <code>NotRequired</code>, which are not allowed elsewhere (the allowed typed qualifiers are documented in the <code>AnnotationSource</code> enum class).</p> <p>A ForbiddenQualifier exception is raised if an invalid qualifier is used. If you want to allow all of them, use the <code>AnnotationSource.ANY</code> annotation source.</p> <p>The result of the <code>inspect_annotation()</code> function contains the underlying type expression, the qualifiers and the annotated metadata.</p>"},{"location":"usage/#handling-bare-type-qualifiers","title":"Handling bare type qualifiers","text":"<p>Note that some qualifiers are allowed to be used without any type expression. In this case, the <code>InspectedAnnotation.type</code> attribute will take the value of the <code>UNKNOWN</code> sentinel.</p> <p>Depending on the type qualifier that was used, you can infer the actual type in different ways:</p> <pre><code>from typing import get_type_hints\n\nfrom typing_inspection.introspection import UNKNOWN, AnnotationSource, inspect_annotation\n\n\nclass A:\n    # For `Final` annotations, the type should be inferred from the assignment\n    # (and you may error if no assignment is available).\n    # In this case, you can infer to either `int` or `Literal[1]`:\n    x: Annotated[Final, 'meta'] = 1\n\n    # For `ClassVar` annotations, the type can be inferred as `Any`,\n    # or from the assignment if available (both options are valid in all cases):\n    y: ClassVar\n\n\ninspected_annotation = inspect_annotation(\n    get_type_hints(A)['x'],\n    annotation_source=AnnotationSource.CLASS,\n)\n\nif inspected_annotation.type is UNKNOWN:\n    ann_type = type(A.x)\nelse:\n    ann_type = inspected_annotation.type\n</code></pre> <p>Parsing PEP 695 type aliases</p> <p>In Python 3.12, the new type statement can be used to define type aliases. When a type alias is wrapped by the <code>Annotated</code> form, the type alias' value will not be unpacked by Python at runtime. This means that while the following is technically valid:</p> <pre><code>type MyInt = Annotated[int, \"int_meta\"]\n\nclass A:\n    x: Annotated[MyInt, \"other_meta\"]\n</code></pre> <p>it might be necessary to parse the type alias during annotation inspection. This behavior can be controlled using the <code>unpack_type_aliases</code> parameter:</p> <pre><code>&gt;&gt;&gt; inspect_annotation(\n...     Annotated[MyInt, \"other_meta\"],\n...     annotation_source=AnnotationSource.CLASS,\n...     unpack_type_aliases=\"eager\",\n... )\n...\nInspectedAnnotation(type=int, qualifiers={}, metadata=[\"int_meta\", \"other_meta\"])\n</code></pre> <p>Whether you should unpack type aliases depends on your use case. If the annotated metadata present in the type alias is only meant to be applied on the annotated type (and not the attribute that will be type hinted), you probably need to keep type aliases as is, and possibly error later if invalid metadata is found when inspecting the type alias.</p> <p>Note that type aliases are lazily evaluated. During type alias inspection, any undefined symbol will raise a <code>NameError</code>. To prevent this from happening, you can use <code>'skip'</code> to avoid expanding type aliases (the default), or <code>'lenient'</code> to fallback to <code>'skip'</code> if the type alias contains an undefined symbol:</p> <pre><code>&gt;&gt;&gt; type BrokenType = Annotated[Undefined, ...]\n&gt;&gt;&gt; type MyAlias = Annotated[BrokenType, \"meta\"]\n&gt;&gt;&gt; inspect_annotation(\n...     MyAlias,\n...     annotation_source=AnnotationSource.CLASS,\n...     unpack_type_aliases=\"lenient\",\n... )\n...\nInspectedAnnotation(type=BrokenType, qualifiers={}, metadata=[\"meta\"])\n</code></pre>"},{"location":"usage/#inspecting-the-type-expression","title":"Inspecting the type expression","text":"<p>With the qualifiers and <code>Annotated</code> forms removed, we can now proceed to inspect the type expression.</p> <p>First of all, some simple typing special forms can be checked:</p> <pre><code>from typing_inspection.typing_objects import is_any, is_self\n\n# This would come from `InspectedAnnotation.type`, after checking for `INFERRED`:\ntype_expr = ...\n\nif is_any(type_expr):\n    ...  # Handle `typing.Any`\n\nif is_self(type_expr):\n    ...  # Handle `typing.Self`\n</code></pre> <p>We will then use the <code>typing.get_origin()</code> function to fetch the origin of the type. Depending on the type, the origin has different meanings:</p> <pre><code>from typing_inspection.introspection import get_literal_values, is_union_origin\nfrom typing_inspection.typing_objects import is_annotated, is_literal\n\norigin = get_origin(type_expr)\n\nif is_union_origin(origin):\n    # Handle `typing.Union` (or the new `|` syntax)\n    union_args = type_expr.__args__\n    ...\n\n# You may also want to check for Annotated forms. While we unwrapped them\n# in step 2, `Annotated` can be used in parts of the annotation, e.g.\n# `list[Annotated[int, ...]]`:\nif is_annotated(origin):\n    annotated_type = type_expr.__origin__  # not to be confused with the origin above\n    metadata = type_expr.__metadata__\n\nif is_literal(origin):\n    # Handle `typing.Literal`\n    literal_values = get_literal_values(type_expr)\n</code></pre> <p>While <code>Literal</code> values can be retrieved using <code>type_expr.__args__</code>, the <code>get_literal_values()</code> function ensures PEP 695 type aliases are properly expanded.</p> <p>Next, we will take care of the typing aliases deprecated by PEP 585. For instance, <code>typing.List</code> is deprecated and replaced by the built-in <code>list</code> type. In this case, the origin of an unparameterized deprecated type alias is the replacement type, so we will use this one:</p> <pre><code>from typing_inspection.typing_objects import DEPRECATED_ALIASES\n\n# If `type_expr` is `typing.List`, `origin` is the built-in `list`.\n# We thus replace `type_expr` with `list`, and set `origin` to `None`\n# to emulate the same behavior if `type_expr` was `list` in the beginning:\nif origin is not None and type_expr in DEPRECATED_ALIASES:\n    type_expr = origin\n    origin = None\n</code></pre> <p>At this point, if <code>origin</code> is not <code>None</code>, you can safely assume that <code>type_expr</code> is a parameterized generic type. You can then define your own logic to handle the type expression, and have different code paths if you are dealing with a parameterized type (e.g. <code>list[int]</code>) or a \"bare\" type:</p> <pre><code>if origin is not None:\n    handle_generic_type(type=origin, arguments=type_expr.__args__)\nelse:\n    handle_type(type=type_expr)\n</code></pre> <p>Note</p> <p>If a deprecated type alias is parameterized (e.g. <code>typing.List[int]</code>), the origin will be the replacement type (e.g. <code>list</code>), and not the deprecated alias (e.g. <code>typing.List</code>). This means that handling <code>typing.List[int]</code> or <code>list</code> should be equivalent.</p>"},{"location":"api/introspection/","title":"introspection","text":"<p>High-level introspection utilities, used to inspect type annotations.</p>"},{"location":"api/introspection/#typing_inspection.introspection.is_union_origin","title":"is_union_origin","text":"<pre><code>is_union_origin(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the provided origin is the union form.</p> <pre><code>&gt;&gt;&gt; is_union_origin(typing.Union)\nTrue\n&gt;&gt;&gt; is_union_origin(get_origin(int | str))\nTrue\n</code></pre>"},{"location":"api/introspection/#typing_inspection.introspection.get_literal_values","title":"get_literal_values","text":"<pre><code>get_literal_values(annotation: Any, /, *, type_check: bool = False, unpack_type_aliases: Literal['skip', 'lenient', 'eager'] = 'eager') -&gt; Generator[Any]\n</code></pre> <p>Yield the values contained in the provided <code>Literal</code> special form.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Any</code> <p>The <code>Literal</code> special form to unpack.</p> required <code>type_check</code> <code>bool</code> <p>Whether to check if the literal values are legal parameters. Raises a <code>TypeError</code> otherwise.</p> <code>False</code> <code>unpack_type_aliases</code> <code>Literal['skip', 'lenient', 'eager']</code> <p>What to do when encountering PEP 695 type aliases. Can be one of:</p> <ul> <li> <p><code>'skip'</code>: Do not try to parse type aliases. Note that this can lead to incorrect results:   <pre><code>&gt;&gt;&gt; type MyAlias = Literal[1, 2]\n&gt;&gt;&gt; list(get_literal_values(Literal[MyAlias, 3], unpack_type_aliases=\"skip\"))\n[MyAlias, 3]\n</code></pre></p> </li> <li> <p><code>'lenient'</code>: Try to parse type aliases, and fallback to <code>'skip'</code> if the type alias can't be inspected   (because of an undefined forward reference).</p> </li> <li> <p><code>'eager'</code>: Parse type aliases and raise any encountered <code>NameError</code> exceptions (the default):   <pre><code>&gt;&gt;&gt; type MyAlias = Literal[1, 2]\n&gt;&gt;&gt; list(get_literal_values(Literal[MyAlias, 3], unpack_type_aliases=\"eager\"))\n[1, 2, 3]\n</code></pre></p> </li> </ul> <code>'eager'</code> Note <p>While <code>None</code> is equivalent to <code>type(None)</code>, the runtime implementation of <code>Literal</code> does not de-duplicate them. This function makes sure this de-duplication is applied:</p> <pre><code>&gt;&gt;&gt; list(get_literal_values(Literal[NoneType, None]))\n[None]\n</code></pre> Example <pre><code>&gt;&gt;&gt; type Ints = Literal[1, 2]\n&gt;&gt;&gt; list(get_literal_values(Literal[1, Ints], unpack_type_alias=\"skip\"))\n[\"a\", Ints]\n&gt;&gt;&gt; list(get_literal_values(Literal[1, Ints]))\n[1, 2]\n&gt;&gt;&gt; list(get_literal_values(Literal[1.0], type_check=True))\nTraceback (most recent call last):\n...\nTypeError: 1.0 is not a valid literal value, must be one of: int, bytes, str, Enum, None.\n</code></pre>"},{"location":"api/introspection/#typing_inspection.introspection.inspect_annotation","title":"inspect_annotation","text":"<pre><code>inspect_annotation(annotation: Any, /, *, annotation_source: AnnotationSource, unpack_type_aliases: Literal['skip', 'lenient', 'eager'] = 'skip') -&gt; InspectedAnnotation\n</code></pre> <p>Inspect an annotation expression, extracting any type qualifier and metadata.</p> <p>An annotation expression is a type expression optionally surrounded by one or more type qualifiers or by <code>Annotated</code>. This function will:</p> <ul> <li>Unwrap the type expression, keeping track of the type qualifiers.</li> <li>Unwrap <code>Annotated</code> forms, keeping track of the annotated metadata.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>Any</code> <p>The annotation expression to be inspected.</p> required <code>annotation_source</code> <code>AnnotationSource</code> <p>The source of the annotation. Depending on the source (e.g. a class), different type qualifiers may be (dis)allowed. To allow any type qualifier, use <code>AnnotationSource.ANY</code>.</p> required <code>unpack_type_aliases</code> <code>Literal['skip', 'lenient', 'eager']</code> <p>What to do when encountering PEP 695 type aliases. Can be one of:</p> <ul> <li> <p><code>'skip'</code>: Do not try to parse type aliases (the default):   <pre><code>&gt;&gt;&gt; type MyInt = Annotated[int, 'meta']\n&gt;&gt;&gt; inspect_annotation(MyInt, annotation_source=AnnotationSource.BARE, unpack_type_aliases='skip')\nInspectedAnnotation(type=MyInt, qualifiers={}, metadata=[])\n</code></pre></p> </li> <li> <p><code>'lenient'</code>: Try to parse type aliases, and fallback to <code>'skip'</code> if the type alias   can't be inspected (because of an undefined forward reference):   <pre><code>&gt;&gt;&gt; type MyInt = Annotated[Undefined, 'meta']\n&gt;&gt;&gt; inspect_annotation(MyInt, annotation_source=AnnotationSource.BARE, unpack_type_aliases='lenient')\nInspectedAnnotation(type=MyInt, qualifiers={}, metadata=[])\n&gt;&gt;&gt; Undefined = int\n&gt;&gt;&gt; inspect_annotation(MyInt, annotation_source=AnnotationSource.BARE, unpack_type_aliases='lenient')\nInspectedAnnotation(type=int, qualifiers={}, metadata=['meta'])\n</code></pre></p> </li> <li> <p><code>'eager'</code>: Parse type aliases and raise any encountered <code>NameError</code> exceptions.</p> </li> </ul> <code>'skip'</code> <p>Returns:</p> Type Description <code>InspectedAnnotation</code> <p>The result of the inspected annotation, where the type expression, used qualifiers and metadata is stored.</p> Example <pre><code>&gt;&gt;&gt; inspect_annotation(\n...     Final[Annotated[ClassVar[Annotated[int, 'meta_1']], 'meta_2']],\n...     annotation_source=AnnotationSource.CLASS,\n... )\n...\nInspectedAnnotation(type=int, qualifiers={'class_var', 'final'}, metadata=['meta_1', 'meta_2'])\n</code></pre>"},{"location":"api/introspection/#typing_inspection.introspection.AnnotationSource","title":"AnnotationSource","text":"<p>               Bases: <code>IntEnum</code></p> <p>The source of an annotation, e.g. a class or a function.</p> <p>Depending on the source, different type qualifiers may be (dis)allowed.</p>"},{"location":"api/introspection/#typing_inspection.introspection.AnnotationSource.ASSIGNMENT_OR_VARIABLE","title":"ASSIGNMENT_OR_VARIABLE","text":"<pre><code>ASSIGNMENT_OR_VARIABLE = auto()\n</code></pre> <p>An annotation used in an assignment or variable annotation:</p> <pre><code>x: Final[int] = 1\ny: Final[str]\n</code></pre> <p>Allowed type qualifiers: <code>Final</code>.</p>"},{"location":"api/introspection/#typing_inspection.introspection.AnnotationSource.CLASS","title":"CLASS","text":"<pre><code>CLASS = auto()\n</code></pre> <p>An annotation used in the body of a class:</p> <pre><code>class Test:\n    x: Final[int] = 1\n    y: ClassVar[str]\n</code></pre> <p>Allowed type qualifiers: <code>ClassVar</code>, <code>Final</code>.</p>"},{"location":"api/introspection/#typing_inspection.introspection.AnnotationSource.DATACLASS","title":"DATACLASS","text":"<pre><code>DATACLASS = auto()\n</code></pre> <p>An annotation used in the body of a dataclass:</p> <pre><code>@dataclass\nclass Test:\n    x: Final[int] = 1\n    y: InitVar[str] = 'test'\n</code></pre> <p>Allowed type qualifiers: <code>ClassVar</code>, <code>Final</code>, <code>InitVar</code>.</p>"},{"location":"api/introspection/#typing_inspection.introspection.AnnotationSource.TYPED_DICT","title":"TYPED_DICT","text":"<pre><code>TYPED_DICT = auto()\n</code></pre> <p>An annotation used in the body of a <code>TypedDict</code>:</p> <pre><code>class TD(TypedDict):\n    x: Required[ReadOnly[int]]\n    y: ReadOnly[NotRequired[str]]\n</code></pre> <p>Allowed type qualifiers: <code>ReadOnly</code>, <code>Required</code>, <code>NotRequired</code>.</p>"},{"location":"api/introspection/#typing_inspection.introspection.AnnotationSource.NAMED_TUPLE","title":"NAMED_TUPLE","text":"<pre><code>NAMED_TUPLE = auto()\n</code></pre> <p>An annotation used in the body of a <code>NamedTuple</code>.</p> <pre><code>class NT(NamedTuple):\n    x: int\n    y: str\n</code></pre> <p>Allowed type qualifiers: none.</p>"},{"location":"api/introspection/#typing_inspection.introspection.AnnotationSource.FUNCTION","title":"FUNCTION","text":"<pre><code>FUNCTION = auto()\n</code></pre> <p>An annotation used in a function, either for a parameter or the return value.</p> <pre><code>def func(a: int) -&gt; str:\n    ...\n</code></pre> <p>Allowed type qualifiers: none.</p>"},{"location":"api/introspection/#typing_inspection.introspection.AnnotationSource.ANY","title":"ANY","text":"<pre><code>ANY = auto()\n</code></pre> <p>An annotation that might come from any source.</p> <p>Allowed type qualifiers: all.</p>"},{"location":"api/introspection/#typing_inspection.introspection.AnnotationSource.BARE","title":"BARE","text":"<pre><code>BARE = auto()\n</code></pre> <p>An annotation that is inspected as is.</p> <p>Allowed type qualifiers: none.</p>"},{"location":"api/introspection/#typing_inspection.introspection.AnnotationSource.allowed_qualifiers","title":"allowed_qualifiers","text":"<pre><code>allowed_qualifiers: set[Qualifier]\n</code></pre> <p>The allowed type qualifiers for this annotation source.</p>"},{"location":"api/introspection/#typing_inspection.introspection.Qualifier","title":"Qualifier","text":"<pre><code>Qualifier: TypeAlias = Literal['required', 'not_required', 'read_only', 'class_var', 'init_var', 'final']\n</code></pre> <p>A type qualifier.</p>"},{"location":"api/introspection/#typing_inspection.introspection.InspectedAnnotation","title":"InspectedAnnotation","text":"<p>               Bases: <code>NamedTuple</code></p> <p>The result of the inspected annotation.</p>"},{"location":"api/introspection/#typing_inspection.introspection.InspectedAnnotation.type","title":"type","text":"<pre><code>type: Any | _UnkownType\n</code></pre> <p>The final type expression, with type qualifiers and annotated metadata stripped.</p> <p>If no type expression is available, the <code>UNKNOWN</code> sentinel value is used instead. This is the case when a type qualifier is used with no type annotation:</p> <pre><code>ID: Final = 1\n\nclass C:\n    x: ClassVar = 'test'\n</code></pre>"},{"location":"api/introspection/#typing_inspection.introspection.InspectedAnnotation.qualifiers","title":"qualifiers","text":"<pre><code>qualifiers: set[Qualifier]\n</code></pre> <p>The type qualifiers present on the annotation.</p>"},{"location":"api/introspection/#typing_inspection.introspection.InspectedAnnotation.metadata","title":"metadata","text":"<pre><code>metadata: Sequence[Any]\n</code></pre> <p>The annotated metadata.</p>"},{"location":"api/introspection/#typing_inspection.introspection.UNKNOWN","title":"UNKNOWN","text":"<pre><code>UNKNOWN = UNKNOWN\n</code></pre> <p>A sentinel value used when no type expression is present.</p>"},{"location":"api/introspection/#typing_inspection.introspection.ForbiddenQualifier","title":"ForbiddenQualifier","text":"<pre><code>ForbiddenQualifier(qualifier: Qualifier)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>The provided type qualifier is forbidden.</p>"},{"location":"api/introspection/#typing_inspection.introspection.ForbiddenQualifier.qualifier","title":"qualifier","text":"<pre><code>qualifier: Qualifier = qualifier\n</code></pre> <p>The forbidden qualifier.</p>"},{"location":"api/typing_objects/","title":"typing_objects","text":"<p>Low-level introspection utilities for <code>typing</code> members.</p> <p>The provided functions in this module check against both the <code>typing</code> and <code>typing_extensions</code> variants, if they exists and are different.</p>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_annotated","title":"is_annotated","text":"<pre><code>is_annotated(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>Annotated</code> special form.</p> <pre><code>&gt;&gt;&gt; is_annotated(Annotated)\nTrue\n&gt;&gt;&gt; is_annotated(Annotated[int, ...])\nFalse\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_any","title":"is_any","text":"<pre><code>is_any(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>Any</code> special form.</p> <pre><code>&gt;&gt;&gt; is_any(Any)\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_classvar","title":"is_classvar","text":"<pre><code>is_classvar(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>ClassVar</code> type qualifier.</p> <pre><code>&gt;&gt;&gt; is_classvar(ClassVar)\nTrue\n&gt;&gt;&gt; is_classvar(ClassVar[int])\n&gt;&gt;&gt; False\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_concatenate","title":"is_concatenate","text":"<pre><code>is_concatenate(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>Concatenate</code> special form.</p> <pre><code>&gt;&gt;&gt; is_concatenate(Concatenate)\nTrue\n&gt;&gt;&gt; is_concatenate(Concatenate[int, P])\nFalse\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_deprecated","title":"is_deprecated","text":"<pre><code>is_deprecated(obj: Any) -&gt; TypeIs[deprecated]\n</code></pre> <p>Return whether the argument is a <code>deprecated</code> instance.</p> <p>This also includes the <code>typing_extensions</code> backport.</p> <pre><code>&gt;&gt;&gt; is_deprecated(warnings.deprecated('message'))\nTrue\n&gt;&gt;&gt; is_deprecated(typing_extensions.deprecated('deprecated'))\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_final","title":"is_final","text":"<pre><code>is_final(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>Final</code> type qualifier.</p> <pre><code>&gt;&gt;&gt; is_final(Final)\nTrue\n&gt;&gt;&gt; is_final(Final[int])\nFalse\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_generic","title":"is_generic","text":"<pre><code>is_generic(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>Generic</code> special form.</p> <pre><code>&gt;&gt;&gt; is_generic(Generic)\nTrue\n&gt;&gt;&gt; is_generic(Generic[T])\nFalse\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_literal","title":"is_literal","text":"<pre><code>is_literal(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>Literal</code> special form.</p> <pre><code>&gt;&gt;&gt; is_literal(Literal)\nTrue\n&gt;&gt;&gt; is_literal(Literal[\"a\"])\nFalse\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_literalstring","title":"is_literalstring","text":"<pre><code>is_literalstring(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>LiteralString</code> special form.</p> <pre><code>&gt;&gt;&gt; is_literalstring(LiteralString)\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_namedtuple","title":"is_namedtuple","text":"<pre><code>is_namedtuple(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is a named tuple type.</p> <p>This includes <code>NamedTuple</code> subclasses and classes created from the <code>collections.namedtuple</code> factory function.</p> <pre><code>&gt;&gt;&gt; class User(NamedTuple):\n...     name: str\n...\n&gt;&gt;&gt; is_namedtuple(User)\nTrue\n&gt;&gt;&gt; City = collections.namedtuple('City', [])\n&gt;&gt;&gt; is_namedtuple(City)\nTrue\n&gt;&gt;&gt; is_namedtuple(NamedTuple)\nFalse\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_never","title":"is_never","text":"<pre><code>is_never(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>Never</code> special form.</p> <pre><code>&gt;&gt;&gt; is_never(Never)\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_newtype","title":"is_newtype","text":"<pre><code>is_newtype(obj: Any) -&gt; TypeIs[NewType]\n</code></pre> <p>Return whether the argument is a <code>NewType</code>.</p> <pre><code>&gt;&gt;&gt; UserId = NewType(\"UserId\", int)\n&gt;&gt;&gt; is_newtype(UserId)\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_nodefault","title":"is_nodefault","text":"<pre><code>is_nodefault(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>NoDefault</code> sentinel object.</p> <pre><code>&gt;&gt;&gt; is_nodefault(NoDefault)\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_noreturn","title":"is_noreturn","text":"<pre><code>is_noreturn(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>NoReturn</code> special form.</p> <pre><code>&gt;&gt;&gt; is_noreturn(NoReturn)\nTrue\n&gt;&gt;&gt; is_noreturn(Never)\nFalse\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_notrequired","title":"is_notrequired","text":"<pre><code>is_notrequired(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>NotRequired</code> special form.</p> <pre><code>&gt;&gt;&gt; is_notrequired(NotRequired)\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_paramspec","title":"is_paramspec","text":"<pre><code>is_paramspec(obj: Any) -&gt; TypeIs[ParamSpec]\n</code></pre> <p>Return whether the argument is an instance of <code>ParamSpec</code>.</p> <pre><code>&gt;&gt;&gt; P = ParamSpec('P')\n&gt;&gt;&gt; is_paramspec(P)\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_paramspecargs","title":"is_paramspecargs","text":"<pre><code>is_paramspecargs(obj: Any) -&gt; TypeIs[ParamSpecArgs]\n</code></pre> <p>Return whether the argument is an instance of <code>ParamSpecArgs</code>.</p> <pre><code>&gt;&gt;&gt; P = ParamSpec('P')\n&gt;&gt;&gt; is_paramspecargs(P.args)\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_paramspeckwargs","title":"is_paramspeckwargs","text":"<pre><code>is_paramspeckwargs(obj: Any) -&gt; TypeIs[ParamSpecKwargs]\n</code></pre> <p>Return whether the argument is an instance of <code>ParamSpecKwargs</code>.</p> <pre><code>&gt;&gt;&gt; P = ParamSpec('P')\n&gt;&gt;&gt; is_paramspeckwargs(P.kwargs)\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_readonly","title":"is_readonly","text":"<pre><code>is_readonly(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>ReadOnly</code> special form.</p> <pre><code>&gt;&gt;&gt; is_readonly(ReadOnly)\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_required","title":"is_required","text":"<pre><code>is_required(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>Required</code> special form.</p> <pre><code>&gt;&gt;&gt; is_required(Required)\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_self","title":"is_self","text":"<pre><code>is_self(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>Self</code> special form.</p> <pre><code>&gt;&gt;&gt; is_self(Self)\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_typealias","title":"is_typealias","text":"<pre><code>is_typealias(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>TypeAlias</code> special form.</p> <pre><code>&gt;&gt;&gt; is_typealias(TypeAlias)\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_typealiastype","title":"is_typealiastype","text":"<pre><code>is_typealiastype(obj: Any) -&gt; TypeIs[TypeAliasType]\n</code></pre> <p>Return whether the argument is a <code>TypeAliasType</code> instance.</p> <pre><code>&gt;&gt;&gt; type MyInt = int\n&gt;&gt;&gt; is_typealiastype(MyInt)\nTrue\n&gt;&gt;&gt; MyStr = TypeAliasType(\"MyStr\", str)\n&gt;&gt;&gt; is_typealiastype(MyStr):\nTrue\n&gt;&gt;&gt; type MyList[T] = list[T]\n&gt;&gt;&gt; is_typealiastype(MyList[int])\nFalse\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_typeguard","title":"is_typeguard","text":"<pre><code>is_typeguard(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>TypeGuard</code> special form.</p> <pre><code>&gt;&gt;&gt; is_typeguard(TypeGuard)\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_typeis","title":"is_typeis","text":"<pre><code>is_typeis(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>TypeIs</code> special form.</p> <pre><code>&gt;&gt;&gt; is_typeis(TypeIs)\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_typevar","title":"is_typevar","text":"<pre><code>is_typevar(obj: Any) -&gt; TypeIs[TypeVar]\n</code></pre> <p>Return whether the argument is an instance of <code>TypeVar</code>.</p> <pre><code>&gt;&gt;&gt; T = TypeVar('T')\n&gt;&gt;&gt; is_typevar(T)\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_typevartuple","title":"is_typevartuple","text":"<pre><code>is_typevartuple(obj: Any) -&gt; TypeIs[TypeVarTuple]\n</code></pre> <p>Return whether the argument is an instance of <code>TypeVarTuple</code>.</p> <pre><code>&gt;&gt;&gt; Ts = TypeVarTuple('Ts')\n&gt;&gt;&gt; is_typevartuple(Ts)\nTrue\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_union","title":"is_union","text":"<pre><code>is_union(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>Union</code> special form.</p> <p>This function can also be used to check for the <code>Optional</code> special form, as at runtime, <code>Optional[int]</code> is equivalent to <code>Union[int, None]</code>.</p> <pre><code>&gt;&gt;&gt; is_union(Union)\nTrue\n&gt;&gt;&gt; is_union(Union[int, str])\nFalse\n</code></pre> <p>Warning</p> <p>This does not check for unions using the new syntax (e.g. <code>int | str</code>).</p>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.is_unpack","title":"is_unpack","text":"<pre><code>is_unpack(obj: Any) -&gt; bool\n</code></pre> <p>Return whether the argument is the <code>Unpack</code> special form.</p> <pre><code>&gt;&gt;&gt; is_unpack(Unpack)\nTrue\n&gt;&gt;&gt; is_unpack(Unpack[Ts])\nFalse\n</code></pre>"},{"location":"api/typing_objects/#typing_inspection.typing_objects.DEPRECATED_ALIASES","title":"DEPRECATED_ALIASES","text":"<pre><code>DEPRECATED_ALIASES: Final[dict[Any, type[Any]]]\n</code></pre> <p>A mapping between the deprecated typing aliases to their replacement, as per PEP 585.</p>"}]}